# Detect Changes Job
#
# Reusable workflow to detect if files matching a pattern have changed.
# Use this to conditionally skip expensive jobs when irrelevant files change.
#
# Usage:
#   detect-changes:
#     uses: ./.github/workflows/job.detect-changes.yml
#     with:
#       paths: "^(yarn\\.lock|apps/|libs/)"
#
#   build:
#     needs: [detect-changes]
#     if: needs.detect-changes.outputs.has-changes == 'true'
#     ...
#
# Common patterns:
#   - Code changes:           "^(yarn\\.lock|apps/|libs/)"
#   - Infrastructure changes: "^infrastructure/"
#   - Helm changes:           "^helm/"
#   - E2E test changes:       "^e2e-tests/"

name: Detect Changes

on:
  workflow_call:
    inputs:
      paths:
        required: true
        type: string
        description: "Regex pattern for paths to check (e.g., '^(yarn\\.lock|apps/|libs/)')"
      cache-key:
        required: false
        type: string
        default: ""
        description: "Cache key for tracking last successful SHA (e.g., 'infra', 'code'). When set, compares against the last successful run instead of the previous commit."
    outputs:
      has-changes:
        description: "Whether changes were detected in the specified paths"
        value: ${{ jobs.detect-changes.outputs.has-changes }}
      current-sha:
        description: "The current SHA being checked"
        value: ${{ jobs.detect-changes.outputs.current-sha }}

jobs:
  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      has-changes: ${{ steps.changes.outputs.has-changes }}
      current-sha: ${{ github.sha }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get last successful SHA
        id: last-success
        if: inputs.cache-key != ''
        uses: actions/cache/restore@v4
        with:
          path: .last-successful-sha
          key: last-successful-${{ inputs.cache-key }}-${{ github.ref_name }}

      - name: Check for changes
        id: changes
        env:
          PATTERN: ${{ inputs.paths }}
          CACHE_KEY: ${{ inputs.cache-key }}
          CACHE_HIT: ${{ steps.last-success.outputs.cache-hit }}
        run: |
          # Determine base SHA for comparison
          # When cache-key is provided: use cached SHA or fall back to origin/master (not event.before)
          # When cache-key is NOT provided: use PR base ref, event.before, or origin/master

          # If cache-key provided and cache exists, use it
          if [ -n "$CACHE_KEY" ] && [ -f ".last-successful-sha" ]; then
            BASE_SHA=$(cat .last-successful-sha)
            echo "Using cached SHA from last successful run: $BASE_SHA"
            # Verify the SHA exists in git history
            if ! git cat-file -e "$BASE_SHA" 2>/dev/null; then
              echo "Warning: Cached SHA $BASE_SHA not found in git history"
              # For PRs, fall back to base branch; for pushes, fall back to origin/master
              if [ -n "${{ github.event.pull_request.base.ref }}" ]; then
                BASE_SHA="origin/${{ github.event.pull_request.base.ref }}"
                echo "Falling back to PR base branch: $BASE_SHA"
              else
                BASE_SHA="origin/master"
                echo "Falling back to origin/master"
              fi
            fi
          # If cache-key provided but NO cache exists, force run (we don't have a reliable baseline)
          # This ensures first run always executes the stage, which will then cache the SHA
          elif [ -n "$CACHE_KEY" ]; then
            if [ -n "${{ github.event.pull_request.base.ref }}" ]; then
              BASE_SHA="origin/${{ github.event.pull_request.base.ref }}"
              echo "No cache found for PR - comparing against base branch: $BASE_SHA"
            else
              echo "No cache found - forcing has-changes=true to establish baseline"
              echo "has-changes=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          # For PRs without cache-key, compare against base branch
          elif [ -n "${{ github.event.pull_request.base.ref }}" ]; then
            BASE_SHA="origin/${{ github.event.pull_request.base.ref }}"
            echo "PR detected - comparing against base branch: $BASE_SHA"
          elif [ -n "${{ github.base_ref }}" ]; then
            BASE_SHA="origin/${{ github.base_ref }}"
            echo "PR detected - comparing against base branch: $BASE_SHA"
          # No cache-key provided, use event.before for incremental detection
          elif [ -n "${{ github.event.before }}" ] && [ "${{ github.event.before }}" != "0000000000000000000000000000000000000000" ]; then
            BASE_SHA="${{ github.event.before }}"
            echo "Using event.before: $BASE_SHA"
          else
            # Fallback to comparing with origin/master
            BASE_SHA="origin/master"
            echo "Fallback to origin/master"
          fi

          echo "Comparing $BASE_SHA...HEAD for pattern: $PATTERN"
          git diff --name-only "$BASE_SHA" HEAD || true

          if git diff --name-only "$BASE_SHA" HEAD | grep -qE "$PATTERN"; then
            echo "has-changes=true" >> "$GITHUB_OUTPUT"
            echo "Changes detected matching pattern: $PATTERN"
          else
            echo "has-changes=false" >> "$GITHUB_OUTPUT"
            echo "No changes detected matching pattern: $PATTERN"
          fi
